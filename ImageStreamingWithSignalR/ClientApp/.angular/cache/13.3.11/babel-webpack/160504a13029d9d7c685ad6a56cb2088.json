{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\nimport { MessageType } from \"./IHubProtocol\";\nimport { LogLevel } from \"./ILogger\";\nimport { Subject } from \"./Subject\";\nimport { Arg } from \"./Utils\";\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\n/** Describes the current state of the {@link HubConnection} to the server. */\n\nexport var HubConnectionState;\n\n(function (HubConnectionState) {\n  /** The hub connection is disconnected. */\n  HubConnectionState[\"Disconnected\"] = \"Disconnected\";\n  /** The hub connection is connecting. */\n\n  HubConnectionState[\"Connecting\"] = \"Connecting\";\n  /** The hub connection is connected. */\n\n  HubConnectionState[\"Connected\"] = \"Connected\";\n  /** The hub connection is disconnecting. */\n\n  HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\n  /** The hub connection is reconnecting. */\n\n  HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\n})(HubConnectionState || (HubConnectionState = {}));\n/** Represents a connection to a SignalR Hub. */\n\n\nvar HubConnection =\n/** @class */\nfunction () {\n  function HubConnection(connection, logger, protocol, reconnectPolicy) {\n    var _this = this;\n\n    this.nextKeepAlive = 0;\n    Arg.isRequired(connection, \"connection\");\n    Arg.isRequired(logger, \"logger\");\n    Arg.isRequired(protocol, \"protocol\");\n    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n    this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\n    this.logger = logger;\n    this.protocol = protocol;\n    this.connection = connection;\n    this.reconnectPolicy = reconnectPolicy;\n    this.handshakeProtocol = new HandshakeProtocol();\n\n    this.connection.onreceive = function (data) {\n      return _this.processIncomingData(data);\n    };\n\n    this.connection.onclose = function (error) {\n      return _this.connectionClosed(error);\n    };\n\n    this.callbacks = {};\n    this.methods = {};\n    this.closedCallbacks = [];\n    this.reconnectingCallbacks = [];\n    this.reconnectedCallbacks = [];\n    this.invocationId = 0;\n    this.receivedHandshakeResponse = false;\n    this.connectionState = HubConnectionState.Disconnected;\n    this.connectionStarted = false;\n    this.cachedPingMessage = this.protocol.writeMessage({\n      type: MessageType.Ping\n    });\n  }\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n\n\n  HubConnection.create = function (connection, logger, protocol, reconnectPolicy) {\n    return new HubConnection(connection, logger, protocol, reconnectPolicy);\n  };\n\n  Object.defineProperty(HubConnection.prototype, \"state\", {\n    /** Indicates the state of the {@link HubConnection} to the server. */\n    get: function () {\n      return this.connectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HubConnection.prototype, \"connectionId\", {\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\n    get: function () {\n      return this.connection ? this.connection.connectionId || null : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HubConnection.prototype, \"baseUrl\", {\n    /** Indicates the url of the {@link HubConnection} to the server. */\n    get: function () {\n      return this.connection.baseUrl || \"\";\n    },\n\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\n    set: function (url) {\n      if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\n        throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n      }\n\n      if (!url) {\n        throw new Error(\"The HubConnection url must be a valid url.\");\n      }\n\n      this.connection.baseUrl = url;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** Starts the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n   */\n\n  HubConnection.prototype.start = function () {\n    this.startPromise = this.startWithStateTransitions();\n    return this.startPromise;\n  };\n\n  HubConnection.prototype.startWithStateTransitions = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.connectionState !== HubConnectionState.Disconnected) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"))];\n            }\n\n            this.connectionState = HubConnectionState.Connecting;\n            this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.startInternal()];\n\n          case 2:\n            _a.sent();\n\n            this.connectionState = HubConnectionState.Connected;\n            this.connectionStarted = true;\n            this.logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            this.connectionState = HubConnectionState.Disconnected;\n            this.logger.log(LogLevel.Debug, \"HubConnection failed to start successfully because of error '\" + e_1 + \"'.\");\n            return [2\n            /*return*/\n            , Promise.reject(e_1)];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.startInternal = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var handshakePromise, handshakeRequest, e_2;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.stopDuringStartError = undefined;\n            this.receivedHandshakeResponse = false;\n            handshakePromise = new Promise(function (resolve, reject) {\n              _this.handshakeResolver = resolve;\n              _this.handshakeRejecter = reject;\n            });\n            return [4\n            /*yield*/\n            , this.connection.start(this.protocol.transferFormat)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 5,, 7]);\n\n            handshakeRequest = {\n              protocol: this.protocol.name,\n              version: this.protocol.version\n            };\n            this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\n            return [4\n            /*yield*/\n            , this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\n\n          case 3:\n            _a.sent();\n\n            this.logger.log(LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\"); // defensively cleanup timeout in case we receive a message from the server before we finish start\n\n            this.cleanupTimeout();\n            this.resetTimeoutPeriod();\n            this.resetKeepAliveInterval();\n            return [4\n            /*yield*/\n            , handshakePromise];\n\n          case 4:\n            _a.sent(); // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\n            // and the connection was closed.\n\n\n            if (this.stopDuringStartError) {\n              // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\n              // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\n              // will cause the calling continuation to get scheduled to run later.\n              throw this.stopDuringStartError;\n            }\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 5:\n            e_2 = _a.sent();\n            this.logger.log(LogLevel.Debug, \"Hub handshake failed with error '\" + e_2 + \"' during start(). Stopping HubConnection.\");\n            this.cleanupTimeout();\n            this.cleanupPingTimer(); // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n\n            return [4\n            /*yield*/\n            , this.connection.stop(e_2)];\n\n          case 6:\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n            _a.sent();\n\n            throw e_2;\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /** Stops the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var startPromise, e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            startPromise = this.startPromise;\n            this.stopPromise = this.stopInternal();\n            return [4\n            /*yield*/\n            , this.stopPromise];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]); // Awaiting undefined continues immediately\n\n\n            return [4\n            /*yield*/\n            , startPromise];\n\n          case 3:\n            // Awaiting undefined continues immediately\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_3 = _a.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.stopInternal = function (error) {\n    if (this.connectionState === HubConnectionState.Disconnected) {\n      this.logger.log(LogLevel.Debug, \"Call to HubConnection.stop(\" + error + \") ignored because it is already in the disconnected state.\");\n      return Promise.resolve();\n    }\n\n    if (this.connectionState === HubConnectionState.Disconnecting) {\n      this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\n      return this.stopPromise;\n    }\n\n    this.connectionState = HubConnectionState.Disconnecting;\n    this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\n\n    if (this.reconnectDelayHandle) {\n      // We're in a reconnect delay which means the underlying connection is currently already stopped.\n      // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\n      // fire the onclose callbacks.\n      this.logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\n      clearTimeout(this.reconnectDelayHandle);\n      this.reconnectDelayHandle = undefined;\n      this.completeClose();\n      return Promise.resolve();\n    }\n\n    this.cleanupTimeout();\n    this.cleanupPingTimer();\n    this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\"); // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\n    // or the onclose callback is invoked. The onclose callback will transition the HubConnection\n    // to the disconnected state if need be before HttpConnection.stop() completes.\n\n    return this.connection.stop(error);\n  };\n  /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n   *\r\n   * @typeparam T The type of the items returned by the server.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n   */\n\n\n  HubConnection.prototype.stream = function (methodName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var _a = this.replaceStreamingParams(args),\n        streams = _a[0],\n        streamIds = _a[1];\n\n    var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\n    var promiseQueue;\n    var subject = new Subject();\n\n    subject.cancelCallback = function () {\n      var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\n\n      delete _this.callbacks[invocationDescriptor.invocationId];\n      return promiseQueue.then(function () {\n        return _this.sendWithProtocol(cancelInvocation);\n      });\n    };\n\n    this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n      if (error) {\n        subject.error(error);\n        return;\n      } else if (invocationEvent) {\n        // invocationEvent will not be null when an error is not passed to the callback\n        if (invocationEvent.type === MessageType.Completion) {\n          if (invocationEvent.error) {\n            subject.error(new Error(invocationEvent.error));\n          } else {\n            subject.complete();\n          }\n        } else {\n          subject.next(invocationEvent.item);\n        }\n      }\n    };\n\n    promiseQueue = this.sendWithProtocol(invocationDescriptor).catch(function (e) {\n      subject.error(e);\n      delete _this.callbacks[invocationDescriptor.invocationId];\n    });\n    this.launchStreams(streams, promiseQueue);\n    return subject;\n  };\n\n  HubConnection.prototype.sendMessage = function (message) {\n    this.resetKeepAliveInterval();\n    return this.connection.send(message);\n  };\n  /**\r\n   * Sends a js object to the server.\r\n   * @param message The js object to serialize and send.\r\n   */\n\n\n  HubConnection.prototype.sendWithProtocol = function (message) {\n    return this.sendMessage(this.protocol.writeMessage(message));\n  };\n  /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n   *\r\n   * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n   * be processing the invocation.\r\n   *\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.send = function (methodName) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var _a = this.replaceStreamingParams(args),\n        streams = _a[0],\n        streamIds = _a[1];\n\n    var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\n    this.launchStreams(streams, sendPromise);\n    return sendPromise;\n  };\n  /** Invokes a hub method on the server using the specified name and arguments.\r\n   *\r\n   * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n   * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n   * resolving the Promise.\r\n   *\r\n   * @typeparam T The expected return type.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.invoke = function (methodName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var _a = this.replaceStreamingParams(args),\n        streams = _a[0],\n        streamIds = _a[1];\n\n    var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\n    var p = new Promise(function (resolve, reject) {\n      // invocationId will always have a value for a non-blocking invocation\n      _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n        if (error) {\n          reject(error);\n          return;\n        } else if (invocationEvent) {\n          // invocationEvent will not be null when an error is not passed to the callback\n          if (invocationEvent.type === MessageType.Completion) {\n            if (invocationEvent.error) {\n              reject(new Error(invocationEvent.error));\n            } else {\n              resolve(invocationEvent.result);\n            }\n          } else {\n            reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\n          }\n        }\n      };\n\n      var promiseQueue = _this.sendWithProtocol(invocationDescriptor).catch(function (e) {\n        reject(e); // invocationId will always have a value for a non-blocking invocation\n\n        delete _this.callbacks[invocationDescriptor.invocationId];\n      });\n\n      _this.launchStreams(streams, promiseQueue);\n    });\n    return p;\n  };\n  /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n   *\r\n   * @param {string} methodName The name of the hub method to define.\r\n   * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n   */\n\n\n  HubConnection.prototype.on = function (methodName, newMethod) {\n    if (!methodName || !newMethod) {\n      return;\n    }\n\n    methodName = methodName.toLowerCase();\n\n    if (!this.methods[methodName]) {\n      this.methods[methodName] = [];\n    } // Preventing adding the same handler multiple times.\n\n\n    if (this.methods[methodName].indexOf(newMethod) !== -1) {\n      return;\n    }\n\n    this.methods[methodName].push(newMethod);\n  };\n\n  HubConnection.prototype.off = function (methodName, method) {\n    if (!methodName) {\n      return;\n    }\n\n    methodName = methodName.toLowerCase();\n    var handlers = this.methods[methodName];\n\n    if (!handlers) {\n      return;\n    }\n\n    if (method) {\n      var removeIdx = handlers.indexOf(method);\n\n      if (removeIdx !== -1) {\n        handlers.splice(removeIdx, 1);\n\n        if (handlers.length === 0) {\n          delete this.methods[methodName];\n        }\n      }\n    } else {\n      delete this.methods[methodName];\n    }\n  };\n  /** Registers a handler that will be invoked when the connection is closed.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n   */\n\n\n  HubConnection.prototype.onclose = function (callback) {\n    if (callback) {\n      this.closedCallbacks.push(callback);\n    }\n  };\n  /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n   */\n\n\n  HubConnection.prototype.onreconnecting = function (callback) {\n    if (callback) {\n      this.reconnectingCallbacks.push(callback);\n    }\n  };\n  /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n   */\n\n\n  HubConnection.prototype.onreconnected = function (callback) {\n    if (callback) {\n      this.reconnectedCallbacks.push(callback);\n    }\n  };\n\n  HubConnection.prototype.processIncomingData = function (data) {\n    this.cleanupTimeout();\n\n    if (!this.receivedHandshakeResponse) {\n      data = this.processHandshakeResponse(data);\n      this.receivedHandshakeResponse = true;\n    } // Data may have all been read when processing handshake response\n\n\n    if (data) {\n      // Parse the messages\n      var messages = this.protocol.parseMessages(data, this.logger);\n\n      for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\n        var message = messages_1[_i];\n\n        switch (message.type) {\n          case MessageType.Invocation:\n            this.invokeClientMethod(message);\n            break;\n\n          case MessageType.StreamItem:\n          case MessageType.Completion:\n            var callback = this.callbacks[message.invocationId];\n\n            if (callback) {\n              if (message.type === MessageType.Completion) {\n                delete this.callbacks[message.invocationId];\n              }\n\n              callback(message);\n            }\n\n            break;\n\n          case MessageType.Ping:\n            // Don't care about pings\n            break;\n\n          case MessageType.Close:\n            this.logger.log(LogLevel.Information, \"Close message received from server.\");\n            var error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\n\n            if (message.allowReconnect === true) {\n              // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\n              // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\n              // tslint:disable-next-line:no-floating-promises\n              this.connection.stop(error);\n            } else {\n              // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\n              this.stopPromise = this.stopInternal(error);\n            }\n\n            break;\n\n          default:\n            this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type + \".\");\n            break;\n        }\n      }\n    }\n\n    this.resetTimeoutPeriod();\n  };\n\n  HubConnection.prototype.processHandshakeResponse = function (data) {\n    var _a;\n\n    var responseMessage;\n    var remainingData;\n\n    try {\n      _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\n    } catch (e) {\n      var message = \"Error parsing handshake response: \" + e;\n      this.logger.log(LogLevel.Error, message);\n      var error = new Error(message);\n      this.handshakeRejecter(error);\n      throw error;\n    }\n\n    if (responseMessage.error) {\n      var message = \"Server returned handshake error: \" + responseMessage.error;\n      this.logger.log(LogLevel.Error, message);\n      var error = new Error(message);\n      this.handshakeRejecter(error);\n      throw error;\n    } else {\n      this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\n    }\n\n    this.handshakeResolver();\n    return remainingData;\n  };\n\n  HubConnection.prototype.resetKeepAliveInterval = function () {\n    if (this.connection.features.inherentKeepAlive) {\n      return;\n    } // Set the time we want the next keep alive to be sent\n    // Timer will be setup on next message receive\n\n\n    this.nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\n    this.cleanupPingTimer();\n  };\n\n  HubConnection.prototype.resetTimeoutPeriod = function () {\n    var _this = this;\n\n    if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n      // Set the timeout timer\n      this.timeoutHandle = setTimeout(function () {\n        return _this.serverTimeout();\n      }, this.serverTimeoutInMilliseconds); // Set keepAlive timer if there isn't one\n\n      if (this.pingServerHandle === undefined) {\n        var nextPing = this.nextKeepAlive - new Date().getTime();\n\n        if (nextPing < 0) {\n          nextPing = 0;\n        } // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\n\n\n        this.pingServerHandle = setTimeout(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var _a;\n\n            return __generator(this, function (_b) {\n              switch (_b.label) {\n                case 0:\n                  if (!(this.connectionState === HubConnectionState.Connected)) return [3\n                  /*break*/\n                  , 4];\n                  _b.label = 1;\n\n                case 1:\n                  _b.trys.push([1, 3,, 4]);\n\n                  return [4\n                  /*yield*/\n                  , this.sendMessage(this.cachedPingMessage)];\n\n                case 2:\n                  _b.sent();\n\n                  return [3\n                  /*break*/\n                  , 4];\n\n                case 3:\n                  _a = _b.sent(); // We don't care about the error. It should be seen elsewhere in the client.\n                  // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\n\n                  this.cleanupPingTimer();\n                  return [3\n                  /*break*/\n                  , 4];\n\n                case 4:\n                  return [2\n                  /*return*/\n                  ];\n              }\n            });\n          });\n        }, nextPing);\n      }\n    }\n  };\n\n  HubConnection.prototype.serverTimeout = function () {\n    // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n    // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\n    // tslint:disable-next-line:no-floating-promises\n    this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n  };\n\n  HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\n    var _this = this;\n\n    var methods = this.methods[invocationMessage.target.toLowerCase()];\n\n    if (methods) {\n      try {\n        methods.forEach(function (m) {\n          return m.apply(_this, invocationMessage.arguments);\n        });\n      } catch (e) {\n        this.logger.log(LogLevel.Error, \"A callback for the method \" + invocationMessage.target.toLowerCase() + \" threw error '\" + e + \"'.\");\n      }\n\n      if (invocationMessage.invocationId) {\n        // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\n        var message = \"Server requested a response, which is not supported in this version of the client.\";\n        this.logger.log(LogLevel.Error, message); // We don't want to wait on the stop itself.\n\n        this.stopPromise = this.stopInternal(new Error(message));\n      }\n    } else {\n      this.logger.log(LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\n    }\n  };\n\n  HubConnection.prototype.connectionClosed = function (error) {\n    this.logger.log(LogLevel.Debug, \"HubConnection.connectionClosed(\" + error + \") called while in state \" + this.connectionState + \".\"); // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\n\n    this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\"); // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\n    // If it has already completed, this should just noop.\n\n    if (this.handshakeResolver) {\n      this.handshakeResolver();\n    }\n\n    this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\n    this.cleanupTimeout();\n    this.cleanupPingTimer();\n\n    if (this.connectionState === HubConnectionState.Disconnecting) {\n      this.completeClose(error);\n    } else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\n      // tslint:disable-next-line:no-floating-promises\n      this.reconnect(error);\n    } else if (this.connectionState === HubConnectionState.Connected) {\n      this.completeClose(error);\n    } // If none of the above if conditions were true were called the HubConnection must be in either:\n    // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\n    // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\n    //    and potentially continue the reconnect() loop.\n    // 3. The Disconnected state in which case we're already done.\n\n  };\n\n  HubConnection.prototype.completeClose = function (error) {\n    var _this = this;\n\n    if (this.connectionStarted) {\n      this.connectionState = HubConnectionState.Disconnected;\n      this.connectionStarted = false;\n\n      try {\n        this.closedCallbacks.forEach(function (c) {\n          return c.apply(_this, [error]);\n        });\n      } catch (e) {\n        this.logger.log(LogLevel.Error, \"An onclose callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\n      }\n    }\n  };\n\n  HubConnection.prototype.reconnect = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            reconnectStartTime = Date.now();\n            previousReconnectAttempts = 0;\n            retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\n            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\n\n            if (nextRetryDelay === null) {\n              this.logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\n              this.completeClose(error);\n              return [2\n              /*return*/\n              ];\n            }\n\n            this.connectionState = HubConnectionState.Reconnecting;\n\n            if (error) {\n              this.logger.log(LogLevel.Information, \"Connection reconnecting because of error '\" + error + \"'.\");\n            } else {\n              this.logger.log(LogLevel.Information, \"Connection reconnecting.\");\n            }\n\n            if (this.onreconnecting) {\n              try {\n                this.reconnectingCallbacks.forEach(function (c) {\n                  return c.apply(_this, [error]);\n                });\n              } catch (e) {\n                this.logger.log(LogLevel.Error, \"An onreconnecting callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\n              } // Exit early if an onreconnecting callback called connection.stop().\n\n\n              if (this.connectionState !== HubConnectionState.Reconnecting) {\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n                return [2\n                /*return*/\n                ];\n              }\n            }\n\n            _a.label = 1;\n\n          case 1:\n            if (!(nextRetryDelay !== null)) return [3\n            /*break*/\n            , 7];\n            this.logger.log(LogLevel.Information, \"Reconnect attempt number \" + previousReconnectAttempts + \" will start in \" + nextRetryDelay + \" ms.\");\n            return [4\n            /*yield*/\n            , new Promise(function (resolve) {\n              _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\n            })];\n\n          case 2:\n            _a.sent();\n\n            this.reconnectDelayHandle = undefined;\n\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\n              this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n              return [2\n              /*return*/\n              ];\n            }\n\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this.startInternal()];\n\n          case 4:\n            _a.sent();\n\n            this.connectionState = HubConnectionState.Connected;\n            this.logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\n\n            if (this.onreconnected) {\n              try {\n                this.reconnectedCallbacks.forEach(function (c) {\n                  return c.apply(_this, [_this.connection.connectionId]);\n                });\n              } catch (e) {\n                this.logger.log(LogLevel.Error, \"An onreconnected callback called with connectionId '\" + this.connection.connectionId + \"; threw error '\" + e + \"'.\");\n              }\n            }\n\n            return [2\n            /*return*/\n            ];\n\n          case 5:\n            e_4 = _a.sent();\n            this.logger.log(LogLevel.Information, \"Reconnect attempt failed because of error '\" + e_4 + \"'.\");\n\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\n              this.logger.log(LogLevel.Debug, \"Connection moved to the '\" + this.connectionState + \"' from the reconnecting state during reconnect attempt. Done reconnecting.\"); // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\n\n              if (this.connectionState === HubConnectionState.Disconnecting) {\n                this.completeClose();\n              }\n\n              return [2\n              /*return*/\n              ];\n            }\n\n            retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());\n            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            return [3\n            /*break*/\n            , 1];\n\n          case 7:\n            this.logger.log(LogLevel.Information, \"Reconnect retries have been exhausted after \" + (Date.now() - reconnectStartTime) + \" ms and \" + previousReconnectAttempts + \" failed attempts. Connection disconnecting.\");\n            this.completeClose();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.getNextRetryDelay = function (previousRetryCount, elapsedMilliseconds, retryReason) {\n    try {\n      return this.reconnectPolicy.nextRetryDelayInMilliseconds({\n        elapsedMilliseconds: elapsedMilliseconds,\n        previousRetryCount: previousRetryCount,\n        retryReason: retryReason\n      });\n    } catch (e) {\n      this.logger.log(LogLevel.Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\" + previousRetryCount + \", \" + elapsedMilliseconds + \") threw error '\" + e + \"'.\");\n      return null;\n    }\n  };\n\n  HubConnection.prototype.cancelCallbacksWithError = function (error) {\n    var callbacks = this.callbacks;\n    this.callbacks = {};\n    Object.keys(callbacks).forEach(function (key) {\n      var callback = callbacks[key];\n      callback(null, error);\n    });\n  };\n\n  HubConnection.prototype.cleanupPingTimer = function () {\n    if (this.pingServerHandle) {\n      clearTimeout(this.pingServerHandle);\n      this.pingServerHandle = undefined;\n    }\n  };\n\n  HubConnection.prototype.cleanupTimeout = function () {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  };\n\n  HubConnection.prototype.createInvocation = function (methodName, args, nonblocking, streamIds) {\n    if (nonblocking) {\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          streamIds: streamIds,\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      } else {\n        return {\n          arguments: args,\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      }\n    } else {\n      var invocationId = this.invocationId;\n      this.invocationId++;\n\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          streamIds: streamIds,\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      } else {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      }\n    }\n  };\n\n  HubConnection.prototype.launchStreams = function (streams, promiseQueue) {\n    var _this = this;\n\n    if (streams.length === 0) {\n      return;\n    } // Synchronize stream data so they arrive in-order on the server\n\n\n    if (!promiseQueue) {\n      promiseQueue = Promise.resolve();\n    }\n\n    var _loop_1 = function (streamId) {\n      streams[streamId].subscribe({\n        complete: function () {\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createCompletionMessage(streamId));\n          });\n        },\n        error: function (err) {\n          var message;\n\n          if (err instanceof Error) {\n            message = err.message;\n          } else if (err && err.toString) {\n            message = err.toString();\n          } else {\n            message = \"Unknown error\";\n          }\n\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createCompletionMessage(streamId, message));\n          });\n        },\n        next: function (item) {\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createStreamItemMessage(streamId, item));\n          });\n        }\n      });\n    }; // We want to iterate over the keys, since the keys are the stream ids\n    // tslint:disable-next-line:forin\n\n\n    for (var streamId in streams) {\n      _loop_1(streamId);\n    }\n  };\n\n  HubConnection.prototype.replaceStreamingParams = function (args) {\n    var streams = [];\n    var streamIds = [];\n\n    for (var i = 0; i < args.length; i++) {\n      var argument = args[i];\n\n      if (this.isObservable(argument)) {\n        var streamId = this.invocationId;\n        this.invocationId++; // Store the stream for later use\n\n        streams[streamId] = argument;\n        streamIds.push(streamId.toString()); // remove stream from args\n\n        args.splice(i, 1);\n      }\n    }\n\n    return [streams, streamIds];\n  };\n\n  HubConnection.prototype.isObservable = function (arg) {\n    // This allows other stream implementations to just work (like rxjs)\n    return arg && arg.subscribe && typeof arg.subscribe === \"function\";\n  };\n\n  HubConnection.prototype.createStreamInvocation = function (methodName, args, streamIds) {\n    var invocationId = this.invocationId;\n    this.invocationId++;\n\n    if (streamIds.length !== 0) {\n      return {\n        arguments: args,\n        invocationId: invocationId.toString(),\n        streamIds: streamIds,\n        target: methodName,\n        type: MessageType.StreamInvocation\n      };\n    } else {\n      return {\n        arguments: args,\n        invocationId: invocationId.toString(),\n        target: methodName,\n        type: MessageType.StreamInvocation\n      };\n    }\n  };\n\n  HubConnection.prototype.createCancelInvocation = function (id) {\n    return {\n      invocationId: id,\n      type: MessageType.CancelInvocation\n    };\n  };\n\n  HubConnection.prototype.createStreamItemMessage = function (id, item) {\n    return {\n      invocationId: id,\n      item: item,\n      type: MessageType.StreamItem\n    };\n  };\n\n  HubConnection.prototype.createCompletionMessage = function (id, error, result) {\n    if (error) {\n      return {\n        error: error,\n        invocationId: id,\n        type: MessageType.Completion\n      };\n    }\n\n    return {\n      invocationId: id,\n      result: result,\n      type: MessageType.Completion\n    };\n  };\n\n  return HubConnection;\n}();\n\nexport { HubConnection };","map":{"version":3,"sources":["C:/Users/STNELL/Desktop/Code/ImageStreamingWithSignalR/ImageStreamingWithSignalR/ClientApp/node_modules/@microsoft/signalr/dist/esm/HubConnection.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","HandshakeProtocol","MessageType","LogLevel","Subject","Arg","DEFAULT_TIMEOUT_IN_MS","DEFAULT_PING_INTERVAL_IN_MS","HubConnectionState","HubConnection","connection","logger","protocol","reconnectPolicy","_this","nextKeepAlive","isRequired","serverTimeoutInMilliseconds","keepAliveIntervalInMilliseconds","handshakeProtocol","onreceive","data","processIncomingData","onclose","error","connectionClosed","callbacks","methods","closedCallbacks","reconnectingCallbacks","reconnectedCallbacks","invocationId","receivedHandshakeResponse","connectionState","Disconnected","connectionStarted","cachedPingMessage","writeMessage","type","Ping","create","Object","defineProperty","prototype","get","enumerable","configurable","connectionId","baseUrl","set","url","Reconnecting","Error","start","startPromise","startWithStateTransitions","e_1","_a","Connecting","log","Debug","startInternal","Connected","handshakePromise","handshakeRequest","e_2","stopDuringStartError","undefined","handshakeResolver","handshakeRejecter","transferFormat","name","version","sendMessage","writeHandshakeRequest","Information","cleanupTimeout","resetTimeoutPeriod","resetKeepAliveInterval","cleanupPingTimer","stop","e_3","stopPromise","stopInternal","Disconnecting","reconnectDelayHandle","clearTimeout","completeClose","stream","methodName","args","_i","arguments","replaceStreamingParams","streams","streamIds","invocationDescriptor","createStreamInvocation","promiseQueue","subject","cancelCallback","cancelInvocation","createCancelInvocation","sendWithProtocol","invocationEvent","Completion","complete","item","catch","launchStreams","message","send","sendPromise","createInvocation","invoke","p","on","newMethod","toLowerCase","indexOf","off","method","handlers","removeIdx","splice","callback","onreconnecting","onreconnected","processHandshakeResponse","messages","parseMessages","messages_1","Invocation","invokeClientMethod","StreamItem","Close","allowReconnect","Warning","responseMessage","remainingData","parseHandshakeResponse","features","inherentKeepAlive","Date","getTime","timeoutHandle","setTimeout","serverTimeout","pingServerHandle","nextPing","_b","invocationMessage","target","forEach","m","cancelCallbacksWithError","reconnect","c","reconnectStartTime","previousReconnectAttempts","retryError","nextRetryDelay","e_4","now","getNextRetryDelay","toString","previousRetryCount","elapsedMilliseconds","retryReason","nextRetryDelayInMilliseconds","keys","key","nonblocking","_loop_1","streamId","subscribe","createCompletionMessage","err","createStreamItemMessage","i","argument","isObservable","arg","StreamInvocation","id","CancelInvocation"],"mappings":"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","sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg } from \"./Utils\";\r\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\r\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport var HubConnectionState;\r\n(function (HubConnectionState) {\r\n    /** The hub connection is disconnected. */\r\n    HubConnectionState[\"Disconnected\"] = \"Disconnected\";\r\n    /** The hub connection is connecting. */\r\n    HubConnectionState[\"Connecting\"] = \"Connecting\";\r\n    /** The hub connection is connected. */\r\n    HubConnectionState[\"Connected\"] = \"Connected\";\r\n    /** The hub connection is disconnecting. */\r\n    HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\r\n    /** The hub connection is reconnecting. */\r\n    HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\r\n})(HubConnectionState || (HubConnectionState = {}));\r\n/** Represents a connection to a SignalR Hub. */\r\nvar HubConnection = /** @class */ (function () {\r\n    function HubConnection(connection, logger, protocol, reconnectPolicy) {\r\n        var _this = this;\r\n        this.nextKeepAlive = 0;\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n        this.logger = logger;\r\n        this.protocol = protocol;\r\n        this.connection = connection;\r\n        this.reconnectPolicy = reconnectPolicy;\r\n        this.handshakeProtocol = new HandshakeProtocol();\r\n        this.connection.onreceive = function (data) { return _this.processIncomingData(data); };\r\n        this.connection.onclose = function (error) { return _this.connectionClosed(error); };\r\n        this.callbacks = {};\r\n        this.methods = {};\r\n        this.closedCallbacks = [];\r\n        this.reconnectingCallbacks = [];\r\n        this.reconnectedCallbacks = [];\r\n        this.invocationId = 0;\r\n        this.receivedHandshakeResponse = false;\r\n        this.connectionState = HubConnectionState.Disconnected;\r\n        this.connectionStarted = false;\r\n        this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    HubConnection.create = function (connection, logger, protocol, reconnectPolicy) {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\r\n    };\r\n    Object.defineProperty(HubConnection.prototype, \"state\", {\r\n        /** Indicates the state of the {@link HubConnection} to the server. */\r\n        get: function () {\r\n            return this.connectionState;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HubConnection.prototype, \"connectionId\", {\r\n        /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n         *  in the disconnected state or if the negotiation step was skipped.\r\n         */\r\n        get: function () {\r\n            return this.connection ? (this.connection.connectionId || null) : null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(HubConnection.prototype, \"baseUrl\", {\r\n        /** Indicates the url of the {@link HubConnection} to the server. */\r\n        get: function () {\r\n            return this.connection.baseUrl || \"\";\r\n        },\r\n        /**\r\n         * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n         * Reconnecting states.\r\n         * @param {string} url The url to connect to.\r\n         */\r\n        set: function (url) {\r\n            if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\r\n                throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n            }\r\n            if (!url) {\r\n                throw new Error(\"The HubConnection url must be a valid url.\");\r\n            }\r\n            this.connection.baseUrl = url;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.start = function () {\r\n        this.startPromise = this.startWithStateTransitions();\r\n        return this.startPromise;\r\n    };\r\n    HubConnection.prototype.startWithStateTransitions = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var e_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (this.connectionState !== HubConnectionState.Disconnected) {\r\n                            return [2 /*return*/, Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"))];\r\n                        }\r\n                        this.connectionState = HubConnectionState.Connecting;\r\n                        this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.startInternal()];\r\n                    case 2:\r\n                        _a.sent();\r\n                        this.connectionState = HubConnectionState.Connected;\r\n                        this.connectionStarted = true;\r\n                        this.logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        e_1 = _a.sent();\r\n                        this.connectionState = HubConnectionState.Disconnected;\r\n                        this.logger.log(LogLevel.Debug, \"HubConnection failed to start successfully because of error '\" + e_1 + \"'.\");\r\n                        return [2 /*return*/, Promise.reject(e_1)];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HubConnection.prototype.startInternal = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var handshakePromise, handshakeRequest, e_2;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.stopDuringStartError = undefined;\r\n                        this.receivedHandshakeResponse = false;\r\n                        handshakePromise = new Promise(function (resolve, reject) {\r\n                            _this.handshakeResolver = resolve;\r\n                            _this.handshakeRejecter = reject;\r\n                        });\r\n                        return [4 /*yield*/, this.connection.start(this.protocol.transferFormat)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 5, , 7]);\r\n                        handshakeRequest = {\r\n                            protocol: this.protocol.name,\r\n                            version: this.protocol.version,\r\n                        };\r\n                        this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n                        return [4 /*yield*/, this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\r\n                    case 3:\r\n                        _a.sent();\r\n                        this.logger.log(LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\");\r\n                        // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n                        this.cleanupTimeout();\r\n                        this.resetTimeoutPeriod();\r\n                        this.resetKeepAliveInterval();\r\n                        return [4 /*yield*/, handshakePromise];\r\n                    case 4:\r\n                        _a.sent();\r\n                        // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n                        // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n                        // and the connection was closed.\r\n                        if (this.stopDuringStartError) {\r\n                            // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                            // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                            // will cause the calling continuation to get scheduled to run later.\r\n                            throw this.stopDuringStartError;\r\n                        }\r\n                        return [3 /*break*/, 7];\r\n                    case 5:\r\n                        e_2 = _a.sent();\r\n                        this.logger.log(LogLevel.Debug, \"Hub handshake failed with error '\" + e_2 + \"' during start(). Stopping HubConnection.\");\r\n                        this.cleanupTimeout();\r\n                        this.cleanupPingTimer();\r\n                        // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n                        // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n                        return [4 /*yield*/, this.connection.stop(e_2)];\r\n                    case 6:\r\n                        // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n                        // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n                        _a.sent();\r\n                        throw e_2;\r\n                    case 7: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.stop = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var startPromise, e_3;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        startPromise = this.startPromise;\r\n                        this.stopPromise = this.stopInternal();\r\n                        return [4 /*yield*/, this.stopPromise];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 4, , 5]);\r\n                        // Awaiting undefined continues immediately\r\n                        return [4 /*yield*/, startPromise];\r\n                    case 3:\r\n                        // Awaiting undefined continues immediately\r\n                        _a.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        e_3 = _a.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HubConnection.prototype.stopInternal = function (error) {\r\n        if (this.connectionState === HubConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, \"Call to HubConnection.stop(\" + error + \") ignored because it is already in the disconnected state.\");\r\n            return Promise.resolve();\r\n        }\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\r\n            return this.stopPromise;\r\n        }\r\n        this.connectionState = HubConnectionState.Disconnecting;\r\n        this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n        if (this.reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this.logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n            clearTimeout(this.reconnectDelayHandle);\r\n            this.reconnectDelayHandle = undefined;\r\n            this.completeClose();\r\n            return Promise.resolve();\r\n        }\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\");\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    };\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    HubConnection.prototype.stream = function (methodName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];\r\n        var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\r\n        var promiseQueue;\r\n        var subject = new Subject();\r\n        subject.cancelCallback = function () {\r\n            var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\r\n            delete _this.callbacks[invocationDescriptor.invocationId];\r\n            return promiseQueue.then(function () {\r\n                return _this.sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n        this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n            else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    }\r\n                    else {\r\n                        subject.complete();\r\n                    }\r\n                }\r\n                else {\r\n                    subject.next((invocationEvent.item));\r\n                }\r\n            }\r\n        };\r\n        promiseQueue = this.sendWithProtocol(invocationDescriptor)\r\n            .catch(function (e) {\r\n            subject.error(e);\r\n            delete _this.callbacks[invocationDescriptor.invocationId];\r\n        });\r\n        this.launchStreams(streams, promiseQueue);\r\n        return subject;\r\n    };\r\n    HubConnection.prototype.sendMessage = function (message) {\r\n        this.resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    };\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    HubConnection.prototype.sendWithProtocol = function (message) {\r\n        return this.sendMessage(this.protocol.writeMessage(message));\r\n    };\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.send = function (methodName) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];\r\n        var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\r\n        this.launchStreams(streams, sendPromise);\r\n        return sendPromise;\r\n    };\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    HubConnection.prototype.invoke = function (methodName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];\r\n        var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\r\n        var p = new Promise(function (resolve, reject) {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        }\r\n                        else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\r\n                    }\r\n                }\r\n            };\r\n            var promiseQueue = _this.sendWithProtocol(invocationDescriptor)\r\n                .catch(function (e) {\r\n                reject(e);\r\n                // invocationId will always have a value for a non-blocking invocation\r\n                delete _this.callbacks[invocationDescriptor.invocationId];\r\n            });\r\n            _this.launchStreams(streams, promiseQueue);\r\n        });\r\n        return p;\r\n    };\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    HubConnection.prototype.on = function (methodName, newMethod) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        if (!this.methods[methodName]) {\r\n            this.methods[methodName] = [];\r\n        }\r\n        // Preventing adding the same handler multiple times.\r\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n        this.methods[methodName].push(newMethod);\r\n    };\r\n    HubConnection.prototype.off = function (methodName, method) {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        var handlers = this.methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            var removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this.methods[methodName];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            delete this.methods[methodName];\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    HubConnection.prototype.onclose = function (callback) {\r\n        if (callback) {\r\n            this.closedCallbacks.push(callback);\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    HubConnection.prototype.onreconnecting = function (callback) {\r\n        if (callback) {\r\n            this.reconnectingCallbacks.push(callback);\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    HubConnection.prototype.onreconnected = function (callback) {\r\n        if (callback) {\r\n            this.reconnectedCallbacks.push(callback);\r\n        }\r\n    };\r\n    HubConnection.prototype.processIncomingData = function (data) {\r\n        this.cleanupTimeout();\r\n        if (!this.receivedHandshakeResponse) {\r\n            data = this.processHandshakeResponse(data);\r\n            this.receivedHandshakeResponse = true;\r\n        }\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            var messages = this.protocol.parseMessages(data, this.logger);\r\n            for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\r\n                var message = messages_1[_i];\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this.invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion:\r\n                        var callback = this.callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this.callbacks[message.invocationId];\r\n                            }\r\n                            callback(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close:\r\n                        this.logger.log(LogLevel.Information, \"Close message received from server.\");\r\n                        var error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n                            // tslint:disable-next-line:no-floating-promises\r\n                            this.connection.stop(error);\r\n                        }\r\n                        else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this.stopPromise = this.stopInternal(error);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type + \".\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        this.resetTimeoutPeriod();\r\n    };\r\n    HubConnection.prototype.processHandshakeResponse = function (data) {\r\n        var _a;\r\n        var responseMessage;\r\n        var remainingData;\r\n        try {\r\n            _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\r\n        }\r\n        catch (e) {\r\n            var message = \"Error parsing handshake response: \" + e;\r\n            this.logger.log(LogLevel.Error, message);\r\n            var error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            var message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this.logger.log(LogLevel.Error, message);\r\n            var error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        else {\r\n            this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n        this.handshakeResolver();\r\n        return remainingData;\r\n    };\r\n    HubConnection.prototype.resetKeepAliveInterval = function () {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n        // Set the time we want the next keep alive to be sent\r\n        // Timer will be setup on next message receive\r\n        this.nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\r\n        this.cleanupPingTimer();\r\n    };\r\n    HubConnection.prototype.resetTimeoutPeriod = function () {\r\n        var _this = this;\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this.timeoutHandle = setTimeout(function () { return _this.serverTimeout(); }, this.serverTimeoutInMilliseconds);\r\n            // Set keepAlive timer if there isn't one\r\n            if (this.pingServerHandle === undefined) {\r\n                var nextPing = this.nextKeepAlive - new Date().getTime();\r\n                if (nextPing < 0) {\r\n                    nextPing = 0;\r\n                }\r\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\r\n                this.pingServerHandle = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {\r\n                    var _a;\r\n                    return __generator(this, function (_b) {\r\n                        switch (_b.label) {\r\n                            case 0:\r\n                                if (!(this.connectionState === HubConnectionState.Connected)) return [3 /*break*/, 4];\r\n                                _b.label = 1;\r\n                            case 1:\r\n                                _b.trys.push([1, 3, , 4]);\r\n                                return [4 /*yield*/, this.sendMessage(this.cachedPingMessage)];\r\n                            case 2:\r\n                                _b.sent();\r\n                                return [3 /*break*/, 4];\r\n                            case 3:\r\n                                _a = _b.sent();\r\n                                // We don't care about the error. It should be seen elsewhere in the client.\r\n                                // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                                this.cleanupPingTimer();\r\n                                return [3 /*break*/, 4];\r\n                            case 4: return [2 /*return*/];\r\n                        }\r\n                    });\r\n                }); }, nextPing);\r\n            }\r\n        }\r\n    };\r\n    HubConnection.prototype.serverTimeout = function () {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // tslint:disable-next-line:no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    };\r\n    HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\r\n        var _this = this;\r\n        var methods = this.methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            try {\r\n                methods.forEach(function (m) { return m.apply(_this, invocationMessage.arguments); });\r\n            }\r\n            catch (e) {\r\n                this.logger.log(LogLevel.Error, \"A callback for the method \" + invocationMessage.target.toLowerCase() + \" threw error '\" + e + \"'.\");\r\n            }\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                var message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this.logger.log(LogLevel.Error, message);\r\n                // We don't want to wait on the stop itself.\r\n                this.stopPromise = this.stopInternal(new Error(message));\r\n            }\r\n        }\r\n        else {\r\n            this.logger.log(LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\r\n        }\r\n    };\r\n    HubConnection.prototype.connectionClosed = function (error) {\r\n        this.logger.log(LogLevel.Debug, \"HubConnection.connectionClosed(\" + error + \") called while in state \" + this.connectionState + \".\");\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\");\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this.handshakeResolver) {\r\n            this.handshakeResolver();\r\n        }\r\n        this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.completeClose(error);\r\n        }\r\n        else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.reconnect(error);\r\n        }\r\n        else if (this.connectionState === HubConnectionState.Connected) {\r\n            this.completeClose(error);\r\n        }\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    };\r\n    HubConnection.prototype.completeClose = function (error) {\r\n        var _this = this;\r\n        if (this.connectionStarted) {\r\n            this.connectionState = HubConnectionState.Disconnected;\r\n            this.connectionStarted = false;\r\n            try {\r\n                this.closedCallbacks.forEach(function (c) { return c.apply(_this, [error]); });\r\n            }\r\n            catch (e) {\r\n                this.logger.log(LogLevel.Error, \"An onclose callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\r\n            }\r\n        }\r\n    };\r\n    HubConnection.prototype.reconnect = function (error) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        reconnectStartTime = Date.now();\r\n                        previousReconnectAttempts = 0;\r\n                        retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n                        nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n                        if (nextRetryDelay === null) {\r\n                            this.logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n                            this.completeClose(error);\r\n                            return [2 /*return*/];\r\n                        }\r\n                        this.connectionState = HubConnectionState.Reconnecting;\r\n                        if (error) {\r\n                            this.logger.log(LogLevel.Information, \"Connection reconnecting because of error '\" + error + \"'.\");\r\n                        }\r\n                        else {\r\n                            this.logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n                        }\r\n                        if (this.onreconnecting) {\r\n                            try {\r\n                                this.reconnectingCallbacks.forEach(function (c) { return c.apply(_this, [error]); });\r\n                            }\r\n                            catch (e) {\r\n                                this.logger.log(LogLevel.Error, \"An onreconnecting callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\r\n                            }\r\n                            // Exit early if an onreconnecting callback called connection.stop().\r\n                            if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                                return [2 /*return*/];\r\n                            }\r\n                        }\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!(nextRetryDelay !== null)) return [3 /*break*/, 7];\r\n                        this.logger.log(LogLevel.Information, \"Reconnect attempt number \" + previousReconnectAttempts + \" will start in \" + nextRetryDelay + \" ms.\");\r\n                        return [4 /*yield*/, new Promise(function (resolve) {\r\n                                _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\r\n                            })];\r\n                    case 2:\r\n                        _a.sent();\r\n                        this.reconnectDelayHandle = undefined;\r\n                        if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                            this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                            return [2 /*return*/];\r\n                        }\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        _a.trys.push([3, 5, , 6]);\r\n                        return [4 /*yield*/, this.startInternal()];\r\n                    case 4:\r\n                        _a.sent();\r\n                        this.connectionState = HubConnectionState.Connected;\r\n                        this.logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n                        if (this.onreconnected) {\r\n                            try {\r\n                                this.reconnectedCallbacks.forEach(function (c) { return c.apply(_this, [_this.connection.connectionId]); });\r\n                            }\r\n                            catch (e) {\r\n                                this.logger.log(LogLevel.Error, \"An onreconnected callback called with connectionId '\" + this.connection.connectionId + \"; threw error '\" + e + \"'.\");\r\n                            }\r\n                        }\r\n                        return [2 /*return*/];\r\n                    case 5:\r\n                        e_4 = _a.sent();\r\n                        this.logger.log(LogLevel.Information, \"Reconnect attempt failed because of error '\" + e_4 + \"'.\");\r\n                        if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                            this.logger.log(LogLevel.Debug, \"Connection moved to the '\" + this.connectionState + \"' from the reconnecting state during reconnect attempt. Done reconnecting.\");\r\n                            // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\r\n                            if (this.connectionState === HubConnectionState.Disconnecting) {\r\n                                this.completeClose();\r\n                            }\r\n                            return [2 /*return*/];\r\n                        }\r\n                        retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());\r\n                        nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n                        return [3 /*break*/, 6];\r\n                    case 6: return [3 /*break*/, 1];\r\n                    case 7:\r\n                        this.logger.log(LogLevel.Information, \"Reconnect retries have been exhausted after \" + (Date.now() - reconnectStartTime) + \" ms and \" + previousReconnectAttempts + \" failed attempts. Connection disconnecting.\");\r\n                        this.completeClose();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HubConnection.prototype.getNextRetryDelay = function (previousRetryCount, elapsedMilliseconds, retryReason) {\r\n        try {\r\n            return this.reconnectPolicy.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds: elapsedMilliseconds,\r\n                previousRetryCount: previousRetryCount,\r\n                retryReason: retryReason,\r\n            });\r\n        }\r\n        catch (e) {\r\n            this.logger.log(LogLevel.Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\" + previousRetryCount + \", \" + elapsedMilliseconds + \") threw error '\" + e + \"'.\");\r\n            return null;\r\n        }\r\n    };\r\n    HubConnection.prototype.cancelCallbacksWithError = function (error) {\r\n        var callbacks = this.callbacks;\r\n        this.callbacks = {};\r\n        Object.keys(callbacks)\r\n            .forEach(function (key) {\r\n            var callback = callbacks[key];\r\n            callback(null, error);\r\n        });\r\n    };\r\n    HubConnection.prototype.cleanupPingTimer = function () {\r\n        if (this.pingServerHandle) {\r\n            clearTimeout(this.pingServerHandle);\r\n            this.pingServerHandle = undefined;\r\n        }\r\n    };\r\n    HubConnection.prototype.cleanupTimeout = function () {\r\n        if (this.timeoutHandle) {\r\n            clearTimeout(this.timeoutHandle);\r\n        }\r\n    };\r\n    HubConnection.prototype.createInvocation = function (methodName, args, nonblocking, streamIds) {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds: streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            var invocationId = this.invocationId;\r\n            this.invocationId++;\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds: streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    };\r\n    HubConnection.prototype.launchStreams = function (streams, promiseQueue) {\r\n        var _this = this;\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n        var _loop_1 = function (streamId) {\r\n            streams[streamId].subscribe({\r\n                complete: function () {\r\n                    promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createCompletionMessage(streamId)); });\r\n                },\r\n                error: function (err) {\r\n                    var message;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    }\r\n                    else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    }\r\n                    else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n                    promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createCompletionMessage(streamId, message)); });\r\n                },\r\n                next: function (item) {\r\n                    promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createStreamItemMessage(streamId, item)); });\r\n                },\r\n            });\r\n        };\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // tslint:disable-next-line:forin\r\n        for (var streamId in streams) {\r\n            _loop_1(streamId);\r\n        }\r\n    };\r\n    HubConnection.prototype.replaceStreamingParams = function (args) {\r\n        var streams = [];\r\n        var streamIds = [];\r\n        for (var i = 0; i < args.length; i++) {\r\n            var argument = args[i];\r\n            if (this.isObservable(argument)) {\r\n                var streamId = this.invocationId;\r\n                this.invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n        return [streams, streamIds];\r\n    };\r\n    HubConnection.prototype.isObservable = function (arg) {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    };\r\n    HubConnection.prototype.createStreamInvocation = function (methodName, args, streamIds) {\r\n        var invocationId = this.invocationId;\r\n        this.invocationId++;\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds: streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    };\r\n    HubConnection.prototype.createCancelInvocation = function (id) {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    };\r\n    HubConnection.prototype.createStreamItemMessage = function (id, item) {\r\n        return {\r\n            invocationId: id,\r\n            item: item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    };\r\n    HubConnection.prototype.createCompletionMessage = function (id, error, result) {\r\n        if (error) {\r\n            return {\r\n                error: error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n        return {\r\n            invocationId: id,\r\n            result: result,\r\n            type: MessageType.Completion,\r\n        };\r\n    };\r\n    return HubConnection;\r\n}());\r\nexport { HubConnection };\r\n"]},"metadata":{},"sourceType":"module"}